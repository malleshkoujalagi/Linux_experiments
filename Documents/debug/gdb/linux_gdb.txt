
1. Enable CONFIG_DEBUG_INFO to debug linux kernel with gdb.
2. Run linux vmlinux with
	sudo gdb vmlinux /proc/kcore
3. Print jiffies
#0  0x0000000000000000 in irq_stack_union ()
(gdb) p jiffies
$1 = 4311562888
(gdb)

4. Flush gdb cache to get new jiffies value like
(gdb) core-file /proc/kcore
[New process 1]
Core was generated by `BOOT_IMAGE=/boot/vmlinuz-4.4.0-rc5+ root=UUID=b7a5eb7f-794c-4496-8333-22bf1d7b1'.
#0  0x0000000000000000 in irq_stack_union ()
(gdb) p jiffies
$2 = 4311583342

5. To load module symbole file we need to get starting address of module.
	I.  Check module info as nm *.ko

		$ nm net_notify.ko
		0000000000000050 T cleanup_module
                 U __fentry__
		0000000000000020 T init_module
		00000000000000a0 r __module_depends
		0000000000000000 T net_dev_event
		0000000000000000 D net_notifier
		0000000000000050 T net_notify_exit
		0000000000000020 T net_notify_init
                 U printk
                 U register_netdevice_notifier
		0000000000000000 D __this_module
		000000000000003b r __UNIQUE_ID_author0
		0000000000000000 r __UNIQUE_ID_description2
		000000000000002f r __UNIQUE_ID_license1
		0000000000000078 r __UNIQUE_ID_srcversion1
		00000000000000a9 r __UNIQUE_ID_vermagic0
                 U unregister_netdevice_notifier
		0000000000000000 r ____versions


	II. Go to ls -Al /sys/module/net_notify/sections/

		-r--r--r-- 1 root root 4096 Jan 18 14:36 .data
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .gnu.linkonce.this_module
		-r--r--r-- 1 root root 4096 Jan 18 14:36 __mcount_loc
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .note.gnu.build-id
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .rodata.str1.1
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .strtab
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .symtab
		-r--r--r-- 1 root root 4096 Jan 18 14:36 .text

	III. Find out .text .data and .bss address

		$ cat .text .data
		0xffffffffc09cd000
		0xffffffffc09cf000
		(gdb) add-symbol-file net_notify.ko 0xffffffffc09cd000 -s .data 0xffffffffc09cf000
			add symbol table from file "net_notify.ko" at
			.text_addr = 0xffffffffc09cd000
			.data_addr = 0xffffffffc09cf000

       like:
       add-symbol-file /home/pi/kernel_hacker/Linux_experiments/user_space_driver_model/kpart.ko  0xffffffffc0a90000 -s .bss 0xffffffffc0a92640 -s .data 0xffffffffc0a92000

6. We can debug all information in module and exlore date infomartion, in all time we need to enter core-file /proc/kcore to update.

NOTE:Link with more details:
https://www.linux.com/learn/linux-training/33991-the-kernel-newbie-corner-kernel-and-module-debugging-with-gdb


7. break Where if Condition
   (gdb) break context_switch if next==init_task

8. command
	
   (gdb) break do_mmap_pgoff
   (gdb) command 1 
	Type commands for when breakpoint 1 is hit, one per line.
	End with a line saying just "end".
	>print addr
	>print len
	>print prot
        >end

9. gdb --args
   gdb --args testpmd -c 0x2 -n 4 --socket-mem=1024 -- -i -a 

10. directory
    (gdb) directory /home/pi/kernel_hack/linux/
    (gdb) list schedule

11. Debugging macros
    (gdb) p GFP_ATOMIC
	No symbol "GFP_ATOMIC" in current context.
   
    make KCFLAGS=-ggdb3
    (gdb) break schedule
    (gdb) continue
    (gdb) p/x GFP_ATOMIC
    $1 = 0x20
    (gdb) p task_is_stopped_or_traced(init_task)
    $2 = 0

    (gdb) macro expand task_is_stopped_or_traced(init_task)
  	expands to: ((init_task->state & (4 | 8)) != 0)
    
    (gdb) info macro task_is_stopped_or_traced
	Defined at include/linux/sched.h:218
  	included at include/linux/nmi.h:7
  	included at kernel/sched.c:31
	#define task_is_stopped_or_traced(task) ((task->state & (__TASK_STOPPED | __TASK_)

12. gdb variable
   (gdb) set $foo = 4
   (gdb) p $foo
    $3 = 4

13. Register variable
   (gdb)break write if $rsi == 2 


14. x command -->x/FMT ADDRESS  
	 (x/x displays elements in hex, x/d displays them as signed decimals, x/c displays characters, x/i disassembles memory as instructions, and x/s interprets memory as C strings
 The SIZE argument can be one of: b, h, w, and g, for one-, two-, four-, and eight-byte blocks, respectively)

    root@pi-2012:~# grep saved_command /proc/kallsyms 
    ffffffff8c0f9008 B saved_command_line
    (gdb) x/s 0xffffffff8c0f9008
     0xffffffff8c0f9008:	"\200j_\216\016\221\377\377"

   (gdb) x/5i schedule
   0xffffffff81802ed0 <schedule>:	callq  0xffffffff81808bd0 <__fentry__>
   0xffffffff81802ed5 <schedule+5>:	push   %rbp
   0xffffffff81802ed6 <schedule+6>:	mov    %gs:0xd340,%rax
   0xffffffff81802edf <schedule+15>:	mov    %rsp,%rbp
   0xffffffff81802ee2 <schedule+18>:	push   %rbx

15. gdb --tui vmlinux /proc/kcore

16. ddd debugger
   sudo apt-get install ddd
   ddd vmlinux /proc/kcore
   and then we can use gdb command to analysis source etc.




